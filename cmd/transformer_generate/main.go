package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	transformsDir := fmt.Sprintf("%s/src/gopkg.in/Clever/optimus.v3/transforms", os.Getenv("GOPATH"))
	outputName := fmt.Sprintf("%s/src/gopkg.in/Clever/optimus.v3/transformer/gen.go", os.Getenv("GOPATH"))

	g := Generator{}
	g.parsePackageDir(transformsDir)

	// Print the header and package clause.
	g.Printf(`
// generated by optimus; DO NOT EDIT

package transformer

import (
"gopkg.in/Clever/optimus.v3"
"gopkg.in/Clever/optimus.v3/transforms"
)
`)
	g.generate()

	// Format the output.
	src := g.format()

	// Write to file.
	if err := ioutil.WriteFile(outputName, src, 0644); err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

type Package struct {
	dir   string
	name  string
	files []*File
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
	pkg *Package     // Package we are scanning.
}

func (g *Generator) generate() {
	for _, file := range g.pkg.files {
		if file.file != nil {
			ast.Inspect(file.file, file.genDecl)
		}
	}
	g.build()
}

func (g *Generator) build() {
	for _, file := range g.pkg.files {
		for _, method := range file.methods {
			g.Printf("%s\n", method)
		}
	}
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// parsePackageDir parses the package residing in the directory.
func (g *Generator) parsePackageDir(directory string) {
	pkg, err := build.Default.ImportDir(directory, 0)
	if err != nil {
		log.Fatalf("cannot process directory %s: %s", directory, err)
	}
	var names []string
	names = append(names, pkg.GoFiles...)
	names = append(names, pkg.CgoFiles...)
	// TODO: Need to think about constants in test files. Maybe write type_string_test.go
	// in a separate pass? For later.
	// names = append(names, pkg.TestGoFiles...) // These are also in the "foo" package.
	names = append(names, pkg.SFiles...)
	names = prefixDirectory(directory, names)
	g.parsePackage(directory, names, nil)
}

// parsePackage analyzes the single package constructed from the named files.
// If text is non-nil, it is a string to be used instead of the content of the file,
// to be used for testing. parsePackage exits if there is an error.
func (g *Generator) parsePackage(directory string, names []string, text interface{}) {
	var files []*File
	var astFiles []*ast.File
	g.pkg = new(Package)
	fs := token.NewFileSet()
	for _, name := range names {
		if !strings.HasSuffix(name, ".go") {
			continue
		}
		parsedFile, err := parser.ParseFile(fs, name, text, 0)
		if err != nil {
			log.Fatalf("parsing package: %s: %s", name, err)
		}
		astFiles = append(astFiles, parsedFile)
		files = append(files, &File{
			file:    parsedFile,
			pkg:     g.pkg,
			methods: []string{},
		})
	}
	if len(astFiles) == 0 {
		log.Fatalf("%s: no buildable Go files", directory)
	}
	g.pkg.name = astFiles[0].Name.Name
	g.pkg.files = files
	g.pkg.dir = directory
}

// File holds a single parsed file and associated data.
type File struct {
	pkg     *Package  // Package to which this file belongs.
	file    *ast.File // Parsed AST.
	methods []string
}

type param struct {
	name     *string
	typ      string
	ellipsis bool
}

func (p *param) String() string {
	if p.name == nil {
		return p.typ
	}
	return fmt.Sprintf("%s %s", *p.name, p.typ)
}

type params []param

func (p params) String() string {
	out := []string{}
	for _, param := range p {
		out = append(out, param.String())
	}
	return strings.Join(out, ", ")
}

func isPrimitive(typ string) bool {
	for _, primitive := range []string{"bool", "byte", "complex128", "complex64", "error",
		"float32", "float64", "int", "int8", "int16", "int32", "int64", "rune", "string",
		"uint", "uint8", "uint16", "uint32", "uint64", "uintptr"} {
		if typ == primitive {
			return true
		}
	}
	return false
}

func parseFieldType(field interface{}) string {
	switch field.(type) {
	case *ast.SelectorExpr:
		val := field.(*ast.SelectorExpr)
		return fmt.Sprintf("%s.%s", val.X.(*ast.Ident).Name, val.Sel.Name)
	case *ast.Ident:
		val := field.(*ast.Ident)
		if isPrimitive(val.Name) {
			return val.Name
		} else {
			return fmt.Sprintf("transforms.%s", val.Name)
		}
	case *ast.FuncType:
		in, out := parseFuncType(field.(*ast.FuncType))
		return fmt.Sprintf("func(%s) (%s)", in.String(), out.String())
	case *ast.ChanType:
		val := field.(*ast.ChanType)
		if val.Arrow == token.NoPos {
			return fmt.Sprintf("chan %s", parseFieldType(val.Value))
		} else if val.Begin < val.Arrow {
			return fmt.Sprintf("chan<- %s", parseFieldType(val.Value))
		} else {
			return fmt.Sprintf("<-chan %s", parseFieldType(val.Value))
		}
	case *ast.MapType:
		val := field.(*ast.MapType)
		return fmt.Sprintf("map[%s]%s", parseFieldType(val.Key), parseFieldType(val.Value))
	case *ast.ArrayType:
		val := field.(*ast.ArrayType)
		// Slice
		if val.Len == nil {
			return fmt.Sprintf("[]%s", val.Elt)
		}
	case *ast.InterfaceType:
		return "interface{}"
	case *ast.Ellipsis:
		val := field.(*ast.Ellipsis)
		return fmt.Sprintf("...%s", parseFieldType(val.Elt))
	}
	panic(fmt.Errorf("unexpected type %T", field))
}

func parseFieldList(fieldList *ast.FieldList) params {
	out := params{}
	for _, field := range fieldList.List {
		typ := parseFieldType(field.Type)
		_, ellipsis := field.Type.(*ast.Ellipsis)
		if len(field.Names) != 0 {
			for _, name := range field.Names {
				out = append(out, param{name: &name.Name, typ: typ, ellipsis: ellipsis})
			}
		} else {
			out = append(out, param{typ: typ, ellipsis: ellipsis})
		}
	}
	return out
}

func parseFuncType(funcType *ast.FuncType) (in, out params) {
	in = parseFieldList(funcType.Params)
	out = parseFieldList(funcType.Results)
	return
}

// genDecl processes one declaration clause.
func (f *File) genDecl(node ast.Node) bool {
	decl, ok := node.(*ast.FuncDecl)
	if !ok {
		return true
	}
	for _, result := range decl.Type.Results.List {
		ret, ok := result.Type.(*ast.SelectorExpr)
		if !ok {
			continue
		}
		ident, ok := ret.X.(*ast.Ident)
		if !ok {
			continue
		}
		if ident.Name != "optimus" || ret.Sel.Name != "TransformFunc" {
			continue
		}
		if decl.Name.Name == "Join" {
			// Join is broken because it has a private type in its signature. It's deprecated anyway
			// so fine with it not being in Transformer.
			continue
		}
		args, _ := parseFuncType(decl.Type)
		method := fmt.Sprintf(`// %s Applies a %s transform.
func (t *Transformer) %s(%s) *Transformer {`, decl.Name, decl.Name, decl.Name, args.String())
		method += fmt.Sprintf("\nreturn t.Apply(transforms.%s(", decl.Name)
		names := []string{}
		for _, arg := range args {
			if !arg.ellipsis {
				names = append(names, *arg.name)
			} else {
				names = append(names, fmt.Sprintf("%s...", *arg.name))
			}
		}
		method += fmt.Sprintf(strings.Join(names, ", "))
		method += "))}"
		f.methods = append(f.methods, method)
	}
	return true
}

// Value represents a declared constant.
type Value struct {
	name string // The name of the constant.
	// The value is stored as a bit pattern alone. The boolean tells us
	// whether to interpret it as an int64 or a uint64; the only place
	// this matters is when sorting.
	// Much of the time the str field is all we need; it is printed
	// by Value.String.
	value  uint64 // Will be converted to int64 when needed.
	signed bool   // Whether the constant is a signed type.
	str    string // The string representation given by the "go/exact" package.
}

// prefixDirectory places the directory name on the beginning of each name in the list.
func prefixDirectory(directory string, names []string) []string {
	if directory == "." {
		return names
	}
	ret := make([]string, len(names))
	for i, name := range names {
		ret[i] = filepath.Join(directory, name)
	}
	return ret
}
