// generated by optimus; DO NOT EDIT

package transformer

import (
	"gopkg.in/Clever/optimus.v3"
	"gopkg.in/Clever/optimus.v3/transforms"
)

// Pair Applies a Pair transform.
func (t *Transformer) Pair(rightTable optimus.Table, leftID transforms.RowIdentifier, rightID transforms.RowIdentifier, filterFn func(optimus.Row) (bool, error)) *Transformer {
	return t.Apply(transforms.Pair(rightTable, leftID, rightID, filterFn))
}

// TableTransform Applies a TableTransform transform.
func (t *Transformer) TableTransform(transform func(optimus.Row, chan<- optimus.Row) error) *Transformer {
	return t.Apply(transforms.TableTransform(transform))
}

// Select Applies a Select transform.
func (t *Transformer) Select(filter func(optimus.Row) (bool, error)) *Transformer {
	return t.Apply(transforms.Select(filter))
}

// Map Applies a Map transform.
func (t *Transformer) Map(transform func(optimus.Row) (optimus.Row, error)) *Transformer {
	return t.Apply(transforms.Map(transform))
}

// Each Applies a Each transform.
func (t *Transformer) Each(fn func(optimus.Row) error) *Transformer {
	return t.Apply(transforms.Each(fn))
}

// Fieldmap Applies a Fieldmap transform.
func (t *Transformer) Fieldmap(mappings map[string][]string) *Transformer {
	return t.Apply(transforms.Fieldmap(mappings))
}

// Valuemap Applies a Valuemap transform.
func (t *Transformer) Valuemap(mappings map[string]map[interface{}]interface{}) *Transformer {
	return t.Apply(transforms.Valuemap(mappings))
}

// Reduce Applies a Reduce transform.
func (t *Transformer) Reduce(fn func(accum optimus.Row, item optimus.Row) error) *Transformer {
	return t.Apply(transforms.Reduce(fn))
}

// Concurrently Applies a Concurrently transform.
func (t *Transformer) Concurrently(fn optimus.TransformFunc, concurrency int) *Transformer {
	return t.Apply(transforms.Concurrently(fn, concurrency))
}

// Concat Applies a Concat transform.
func (t *Transformer) Concat(tables ...optimus.Table) *Transformer {
	return t.Apply(transforms.Concat(tables...))
}

// Unique Applies a Unique transform.
func (t *Transformer) Unique(hash transforms.RowIdentifier) *Transformer {
	return t.Apply(transforms.Unique(hash))
}
